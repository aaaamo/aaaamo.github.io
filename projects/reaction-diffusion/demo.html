<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction-Diffusion System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
        }

        input[type="file"] {
            width: 100%;
            margin-top: 5px;
            font-size: 11px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #45a049;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #4CAF50;
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            font-size: 16px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .preset-btn {
            background: #2196F3;
            margin-top: 2px;
            padding: 8px;
            font-size: 11px;
        }

        .preset-btn:hover {
            background: #0b7dda;
        }

        .brush-size {
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="controls">
        <h3>Reaction-Diffusion Controls</h3>

        <div class="control-group">
            <label>Image Upload</label>
            <input type="file" id="imageUpload" accept="image/*">
        </div>

        <div class="control-group">
            <label>Feed Rate (f): <span class="value-display" id="feedValue">0.0550</span></label>
            <input type="range" id="feed" min="0.001" max="0.1" step="0.0001" value="0.055">
            <small style="color: #888; font-size: 10px;">Higher = thicker lines</small>
        </div>

        <div class="control-group">
            <label>Kill Rate (k): <span class="value-display" id="killValue">0.06450</span></label>
            <input type="range" id="kill" min="0.02" max="0.07" step="0.0001" value="0.0645">
            <small style="color: #888; font-size: 10px;">Lower = thicker lines</small>
        </div>

        <div class="control-group">
            <label>Diffusion A (dA): <span class="value-display" id="diffAValue">0.21</span></label>
            <input type="range" id="diffA" min="0.1" max="2.0" step="0.01" value="0.2097">
        </div>

        <div class="control-group">
            <label>Diffusion B (dB): <span class="value-display" id="diffBValue">0.11</span></label>
            <input type="range" id="diffB" min="0.05" max="1.0" step="0.01" value="0.105">
        </div>

        <div class="control-group">
            <label>Time Step (dt): <span class="value-display" id="timeStepValue">1.0</span></label>
            <input type="range" id="timeStep" min="0.01" max="2.0" step="0.01" value="1.0">
        </div>

        <div class="control-group">
            <label>Iterations/Frame: <span class="value-display" id="iterValue">20</span></label>
            <input type="range" id="iterations" min="1" max="50" step="1" value="20">
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="enableMic"> Drive by Microphone
            </label>
        </div>

        <div class="control-group">
            <label>Sample Interval (ms): <span class="value-display" id="micIntervalValue">500</span></label>
            <input type="range" id="micInterval" min="100" max="2000" step="50" value="500">
        </div>

        <div class="control-group">
            <label>Loudness â†’ Brush Scale: <span class="value-display" id="micBrushScaleValue">80</span></label>
            <input type="range" id="micBrushScale" min="10" max="200" step="5" value="80">
        </div>

        <div class="control-group">
            <label>Fade Half-life (s): <span class="value-display" id="fadeHalfValue">10</span></label>
            <input type="range" id="fadeHalf" min="1" max="60" step="1" value="10">
        </div>
        <div class="control-group">
            <label><input type="checkbox" id="fadeEnable"> Enable Fade</label>
        </div>

        <div class="control-group brush-size">
            <label>Brush Size: <span class="value-display" id="brushValue">5</span></label>
            <input type="range" id="brushSize" min="5" max="20" step="1" value="5">
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="invertColors"> Invert Black/White
            </label>
        </div>

        <button id="reset">Reset Simulation</button>
        <button id="clearDraw">Clear Drawing</button>

        <h3 style="margin-top: 20px; font-size: 14px;">Presets</h3>
        <div id="presetButtons"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let simulationMaterial, displayMaterial, drawMaterial;
        let renderTargets = [];
        let currentTarget = 0;
        let quad;
        let params = {
            feed: 0.055,
            kill: 0.0645,
            diffA: 0.2097,
            diffB: 0.105,
            timeStep: 1.0,
            iterations: 20,
            brushSize: 5
        };
        let isDrawing = false;
        let mousePos = new THREE.Vector2();
        let canvasSize = 800;

        let audioCtx = null, analyser = null, micSource = null, micTimer = null;
        let micEnabled = false;
        let sampleIntervalMs = 500;
        let micBrushScale = 80;
        const micBufSize = 4096;
        let micBuf = null;
        let lastMicXY = null;

        const RMS_MIN = 0.01;
        const PITCH_MIN_HZ = 55;
        const PITCH_MAX_HZ = 2000;

        let fadeEnabled = false;
        let fadeHalfLife = 10;

        const presets = {
            "jsexp": { feed: 0.037, kill: 0.06, da: 0.2097, db: 0.105 },
            "Coral": { feed: 0.0545, kill: 0.062, da: 0.2097, db: 0.105 },
            "Culture": { feed: 0.082, kill: 0.06, da: 0.2097, db: 0.105 },
            "Bacteria": { feed: 0.078, kill: 0.061, da: 0.2097, db: 0.105 },
            "Mitosis": { feed: 0.0367, kill: 0.0649, da: 0.2097, db: 0.105 },
            "Moving": { feed: 0.073, kill: 0.061, da: 0.2097, db: 0.105 },
            "Radial": { feed: 0.039, kill: 0.059, da: 0.2097, db: 0.105 },
            "Pulsating": { feed: 0.026, kill: 0.059, da: 0.2097, db: 0.105 },
            "Psychedelic": { feed: 0.025, kill: 0.051, da: 0.2097, db: 0.105 },
            "Moving Squigglies": { feed: 0.012, kill: 0.051, da: 0.2097, db: 0.105 },
            "Ripples": { feed: 0.01, kill: 0.044, da: 0.2097, db: 0.105 },
            "Turbulence": { feed: 0.003, kill: 0.022, da: 0.2097, db: 0.105 },
            "Lava Lamp": { feed: 0.01, kill: 0.051, da: 0.237, db: 0.109 }
        };

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        async function startMic() {
            if (micEnabled) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                await audioCtx.resume();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 8192;
                micSource = audioCtx.createMediaStreamSource(stream);
                micSource.connect(analyser);
                micBuf = new Float32Array(analyser.fftSize);
                micEnabled = true;
                restartMicTimer();
            } catch (err) {
                console.error('Mic error:', err);
                document.getElementById('enableMic').checked = false;
                micEnabled = false;
            }
        }

        function stopMic() {
            micEnabled = false;
            if (micTimer) { clearInterval(micTimer); micTimer = null; }
            try { micSource && micSource.mediaStream.getTracks().forEach(t => t.stop()); } catch { }
            try { audioCtx && audioCtx.close(); } catch { }
            audioCtx = analyser = micSource = null;
        }

        function restartMicTimer() {
            if (micTimer) clearInterval(micTimer);
            micTimer = setInterval(sampleMicAndPaint, sampleIntervalMs);
        }

        function sampleMicAndPaint() {
            if (!analyser || !micEnabled) return;
            if (audioCtx && audioCtx.state !== 'running') {
                audioCtx.resume().catch(() => { });
            }

            analyser.getFloatTimeDomainData(micBuf);
            const { rms, pitchHz } = featuresFromBuffer(micBuf, audioCtx.sampleRate);

            if (rms < RMS_MIN) return;

            const x = hzToCanvasX(pitchHz, PITCH_MIN_HZ, PITCH_MAX_HZ, canvasSize);
            if (!isFinite(x)) return;

            const y = loudnessToCanvasY(rms, canvasSize);
            const size = Math.max(5, micBrushScale * rms);

            injectDab(x, y, size);
            lastMicXY = { x, y };
        }

        function featuresFromBuffer(buf, sr) {
            let sum = 0;
            for (let i = 0; i < buf.length; i++) { const v = buf[i]; sum += v * v; }
            const rms = Math.sqrt(sum / buf.length);

            const maxLag = Math.floor(sr / 55);
            const minLag = Math.floor(sr / 2000);
            let bestLag = 0, bestCorr = 0;

            let mean = 0;
            for (let i = 0; i < buf.length; i++) mean += buf[i];
            mean /= buf.length;
            for (let i = 0; i < buf.length; i++) buf[i] -= mean;

            for (let lag = minLag; lag <= maxLag; lag++) {
                let corr = 0;
                for (let i = 0; i < buf.length - lag; i++) {
                    corr += buf[i] * buf[i + lag];
                }
                if (corr > bestCorr) { bestCorr = corr; bestLag = lag; }
            }

            let pitchHz = 0;
            if (bestLag > 0 && bestCorr > 0.001) {
                const c0 = acfAtLag(buf, bestLag - 1);
                const c1 = acfAtLag(buf, bestLag);
                const c2 = acfAtLag(buf, bestLag + 1);
                const denom = (2 * c1 - c0 - c2);
                const delta = denom !== 0 ? 0.5 * (c0 - c2) / denom : 0;
                const refinedLag = bestLag + delta;
                pitchHz = sr / refinedLag;
            }

            if (!isFinite(pitchHz) || pitchHz < 55 || pitchHz > 2000) pitchHz = 0;
            return { rms, pitchHz };
        }

        function acfAtLag(buf, lag) {
            if (lag < 1 || lag >= buf.length) return 0;
            let s = 0;
            for (let i = 0; i < buf.length - lag; i++) s += buf[i] * buf[i + lag];
            return s;
        }

        function hzToCanvasX(hz, lo, hi, W) {
            if (!(hz > 0)) return NaN;
            const l2 = Math.log2, t = (l2(hz) - l2(lo)) / (l2(hi) - l2(lo));
            return Math.min(W - 1, Math.max(0, t * W));
        }

        function loudnessToCanvasY(rms, H) {
            const db = 20 * Math.log10(Math.max(1e-6, rms));
            const t = (db + 60) / 60;
            const v = Math.min(1, Math.max(0, t));
            return (1 - v) * (H - 1);
        }

        function injectDab(x, y, size) {
            drawMaterial.uniforms.tDiffuse.value = renderTargets[currentTarget].texture;
            drawMaterial.uniforms.brushPos.value.set(x, y);
            drawMaterial.uniforms.brushSize.value = size;
            drawMaterial.uniforms.isDrawing.value = true;

            quad.material = drawMaterial;
            const nextTarget = 1 - currentTarget;
            renderer.setRenderTarget(renderTargets[nextTarget]);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            currentTarget = nextTarget;

            drawMaterial.uniforms.isDrawing.value = false;
            drawMaterial.uniforms.brushSize.value = params.brushSize;
        }

        const simulationFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform float feed;
            uniform float kill;
            uniform float dA;
            uniform float dB;
            uniform float dt;
            uniform vec2 resolution;
            varying vec2 vUv;
            uniform float fadeLambda;

            void main() {
                vec2 texel = 1.0 / resolution;
                vec2 uv = texture2D(tDiffuse, vUv).rg;
                float a = uv.r;
                float b = uv.g;
                
                // 9-point isotropic Laplacian stencil
                // Based on https://en.wikipedia.org/wiki/Discrete_Laplace_operator
                vec2 laplacian = vec2(0.0);
                
                // Orthogonal neighbors: weight 0.5
                laplacian += texture2D(tDiffuse, vUv + vec2(-texel.x, 0.0)).rg * 0.5;
                laplacian += texture2D(tDiffuse, vUv + vec2(texel.x, 0.0)).rg * 0.5;
                laplacian += texture2D(tDiffuse, vUv + vec2(0.0, -texel.y)).rg * 0.5;
                laplacian += texture2D(tDiffuse, vUv + vec2(0.0, texel.y)).rg * 0.5;
                
                // Diagonal neighbors: weight 0.25
                laplacian += texture2D(tDiffuse, vUv + vec2(-texel.x, -texel.y)).rg * 0.25;
                laplacian += texture2D(tDiffuse, vUv + vec2(texel.x, -texel.y)).rg * 0.25;
                laplacian += texture2D(tDiffuse, vUv + vec2(-texel.x, texel.y)).rg * 0.25;
                laplacian += texture2D(tDiffuse, vUv + vec2(texel.x, texel.y)).rg * 0.25;
                
                // Center: weight -3 (sum of all neighbors)
                laplacian -= uv * 3.0;
                
                float abb = a * b * b;
                float da = dA * laplacian.r - abb + feed * (1.0 - a);
                float db = dB * laplacian.g + abb - (kill + feed) * b;
                
                a += da * dt;
                b += db * dt;
                a = clamp(a, 0.0, 1.0);
                b = clamp(b, 0.0, 1.0);
                
                float fadeStep = clamp(fadeLambda * dt, 0.0, 1.0);
                a = mix(a, 1.0, fadeStep);
                b = mix(b, 0.0, fadeStep);

                gl_FragColor = vec4(a, b, 0.0, 1.0);
            }
        `;

        const displayFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform bool invertColors;
            varying vec2 vUv;

            void main() {
                vec2 uv = texture2D(tDiffuse, vUv).rg;
                float b = uv.g;
                float value = invertColors ? b : (1.0 - b);
                vec3 color = vec3(value);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const drawFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform vec2 brushPos;
            uniform float brushSize;
            uniform bool isDrawing;
            uniform vec2 resolution;
            varying vec2 vUv;

            void main() {
                vec4 color = texture2D(tDiffuse, vUv);
                
                if (isDrawing) {
                    vec2 pixelPos = vUv * resolution;
                    float dist = distance(pixelPos, brushPos);
                    
                    if (dist < brushSize) {
                        float strength = 1.0 - (dist / brushSize);
                        strength = smoothstep(0.0, 1.0, strength);
                        color.g += strength * 0.5;
                        color.g = clamp(color.g, 0.0, 1.0);
                    }
                }
                
                gl_FragColor = color;
            }
        `;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasSize, canvasSize);
            container.appendChild(renderer.domElement);

            for (let i = 0; i < 2; i++) {
                renderTargets.push(new THREE.WebGLRenderTarget(canvasSize, canvasSize, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType
                }));
            }

            simulationMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    feed: { value: params.feed },
                    kill: { value: params.kill },
                    dA: { value: params.diffA },
                    dB: { value: params.diffB },
                    dt: { value: params.timeStep },
                    resolution: { value: new THREE.Vector2(canvasSize, canvasSize) },
                    fadeLambda: { value: 0.0 }
                },
                vertexShader: vertexShader,
                fragmentShader: simulationFragmentShader
            });

            displayMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    invertColors: { value: false }
                },
                vertexShader: vertexShader,
                fragmentShader: displayFragmentShader
            });

            drawMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    brushPos: { value: new THREE.Vector2() },
                    brushSize: { value: params.brushSize },
                    isDrawing: { value: false },
                    resolution: { value: new THREE.Vector2(canvasSize, canvasSize) }
                },
                vertexShader: vertexShader,
                fragmentShader: drawFragmentShader
            });

            const geometry = new THREE.PlaneGeometry(2, 2);
            quad = new THREE.Mesh(geometry, displayMaterial);
            scene.add(quad);

            initializeTexture();
            setupControls();
            setupMouseEvents();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function initializeTexture(image = null) {
            const width = canvasSize;
            const height = canvasSize;
            const data = new Float32Array(width * height * 4);

            if (image) {
                // const canvas = document.createElement('canvas');
                // canvas.width = width;
                // canvas.height = height;
                // const ctx = canvas.getContext('2d');
                // ctx.drawImage(image, 0, 0, width, height);
                // const imageData = ctx.getImageData(0, 0, width, height);

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                ctx.translate(0, height);
                ctx.scale(1, -1);
                ctx.drawImage(image, 0, 0, width, height);
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                const imageData = ctx.getImageData(0, 0, width, height);

                for (let i = 0; i < width * height; i++) {
                    const gray = imageData.data[i * 4] / 255.0;
                    data[i * 4] = 1.0;
                    data[i * 4 + 1] = gray > 0.5 ? 0.5 + Math.random() * 0.5 : Math.random() * 0.1;
                    data[i * 4 + 2] = 0.0;
                    data[i * 4 + 3] = 1.0;
                }
            } else {
                for (let i = 0; i < width * height; i++) {
                    data[i * 4 + 0] = 1.0;
                    data[i * 4 + 1] = 0.0;
                    data[i * 4 + 2] = 0.0;
                    data[i * 4 + 3] = 1.0;
                }
            }

            const initialTexture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat, THREE.FloatType);
            initialTexture.needsUpdate = true;

            const tempMaterial = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: { value: initialTexture } },
                vertexShader: vertexShader,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    void main() {
                        gl_FragColor = texture2D(tDiffuse, vUv);
                    }
                `
            });

            quad.material = tempMaterial;
            renderer.setRenderTarget(renderTargets[0]);
            renderer.render(scene, camera);
            renderer.setRenderTarget(renderTargets[1]);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            quad.material = displayMaterial;
        }

        function setupMouseEvents() {
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                updateMousePos(e);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) updateMousePos(e);
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                updateTouchPos(e);
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isDrawing) updateTouchPos(e);
            });

            canvas.addEventListener('touchend', () => {
                isDrawing = false;
            });
        }

        function updateMousePos(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mousePos.x = ((e.clientX - rect.left) / rect.width) * canvasSize;
            mousePos.y = (1 - (e.clientY - rect.top) / rect.height) * canvasSize;
        }

        function updateTouchPos(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const touch = e.touches[0];
            mousePos.x = ((touch.clientX - rect.left) / rect.width) * canvasSize;
            mousePos.y = (1 - (touch.clientY - rect.top) / rect.height) * canvasSize;
        }

        function setupControls() {
            const controls = {
                feed: document.getElementById('feed'),
                kill: document.getElementById('kill'),
                diffA: document.getElementById('diffA'),
                diffB: document.getElementById('diffB'),
                timeStep: document.getElementById('timeStep'),
                iterations: document.getElementById('iterations'),
                brushSize: document.getElementById('brushSize')
            };

            const values = {
                feed: document.getElementById('feedValue'),
                kill: document.getElementById('killValue'),
                diffA: document.getElementById('diffAValue'),
                diffB: document.getElementById('diffBValue'),
                timeStep: document.getElementById('timeStepValue'),
                iterations: document.getElementById('iterValue'),
                brushSize: document.getElementById('brushValue')
            };

            const enableMic = document.getElementById('enableMic');
            const micInterval = document.getElementById('micInterval');
            const micIntervalValue = document.getElementById('micIntervalValue');
            const micBrushScaleEl = document.getElementById('micBrushScale');
            const micBrushScaleValue = document.getElementById('micBrushScaleValue');

            enableMic.addEventListener('change', async (e) => {
                if (e.target.checked) {
                    await startMic();
                } else {
                    stopMic();
                }
            });

            micInterval.addEventListener('input', (e) => {
                sampleIntervalMs = parseInt(e.target.value, 10);
                micIntervalValue.textContent = sampleIntervalMs;
                if (micEnabled) restartMicTimer();
            });

            micBrushScaleEl.addEventListener('input', (e) => {
                micBrushScale = parseFloat(e.target.value);
                micBrushScaleValue.textContent = micBrushScale;
            });

            Object.keys(controls).forEach(key => {
                controls[key].addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    params[key] = value;

                    if (key === 'brushSize') {
                        values[key].textContent = Math.floor(value);
                        drawMaterial.uniforms.brushSize.value = value;
                    } else {
                        values[key].textContent = value.toFixed(4);
                        if (key !== 'iterations') {
                            const uniformKey = key === 'timeStep' ? 'dt' : key;
                            simulationMaterial.uniforms[uniformKey].value = value;
                        }
                    }
                });
            });

            document.getElementById('reset').addEventListener('click', () => {
                initializeTexture();
            });

            document.getElementById('clearDraw').addEventListener('click', () => {
                initializeTexture();
            });

            document.getElementById('invertColors').addEventListener('change', (e) => {
                displayMaterial.uniforms.invertColors.value = e.target.checked;
            });

            document.getElementById('imageUpload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            initializeTexture(img);
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            const fadeHalf = document.getElementById('fadeHalf');
            const fadeHalfValue = document.getElementById('fadeHalfValue');
            const fadeEnable = document.getElementById('fadeEnable');

            fadeHalf.addEventListener('input', (e) => {
                fadeHalfLife = parseInt(e.target.value, 10);
                fadeHalfValue.textContent = fadeHalfLife;
                simulationMaterial.uniforms.fadeLambda.value = fadeEnabled ? Math.LN2 / Math.max(0.001, fadeHalfLife) : 0.0;
            });

            fadeEnable.addEventListener('change', (e) => {
                fadeEnabled = e.target.checked;
                simulationMaterial.uniforms.fadeLambda.value = fadeEnabled ? Math.LN2 / Math.max(0.001, fadeHalfLife) : 0.0;
            });

            document.getElementById('micIntervalValue').textContent = sampleIntervalMs;
            document.getElementById('micBrushScaleValue').textContent = micBrushScale;
            fadeHalfValue.textContent = fadeHalfLife;

            // Create preset buttons dynamically
            const presetContainer = document.getElementById('presetButtons');
            Object.keys(presets).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'preset-btn';
                btn.textContent = key;
                btn.addEventListener('click', () => {
                    setPreset(presets[key]);
                });
                presetContainer.appendChild(btn);
            });
        }

        function setPreset(preset) {
            params.feed = preset.feed;
            params.kill = preset.kill;
            params.diffA = preset.da;
            params.diffB = preset.db;

            document.getElementById('feed').value = preset.feed;
            document.getElementById('kill').value = preset.kill;
            document.getElementById('diffA').value = preset.da;
            document.getElementById('diffB').value = preset.db;

            document.getElementById('feedValue').textContent = preset.feed.toFixed(4);
            document.getElementById('killValue').textContent = preset.kill.toFixed(4);
            document.getElementById('diffAValue').textContent = preset.da.toFixed(4);
            document.getElementById('diffBValue').textContent = preset.db.toFixed(4);

            simulationMaterial.uniforms.feed.value = preset.feed;
            simulationMaterial.uniforms.kill.value = preset.kill;
            simulationMaterial.uniforms.dA.value = preset.da;
            simulationMaterial.uniforms.dB.value = preset.db;

            // initializeTexture();
        }

        function onWindowResize() {
            const size = Math.min(window.innerWidth, window.innerHeight, 1000);
            renderer.setSize(size, size);
        }

        function applyDrawing() {
            if (isDrawing) {
                drawMaterial.uniforms.tDiffuse.value = renderTargets[currentTarget].texture;
                drawMaterial.uniforms.brushPos.value = mousePos;
                drawMaterial.uniforms.isDrawing.value = true;

                quad.material = drawMaterial;
                const nextTarget = 1 - currentTarget;
                renderer.setRenderTarget(renderTargets[nextTarget]);
                renderer.render(scene, camera);
                currentTarget = nextTarget;

                drawMaterial.uniforms.isDrawing.value = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            applyDrawing();

            quad.material = simulationMaterial;
            for (let i = 0; i < params.iterations; i++) {
                simulationMaterial.uniforms.tDiffuse.value = renderTargets[currentTarget].texture;
                const nextTarget = 1 - currentTarget;
                renderer.setRenderTarget(renderTargets[nextTarget]);
                renderer.render(scene, camera);
                currentTarget = nextTarget;
            }

            quad.material = displayMaterial;
            displayMaterial.uniforms.tDiffuse.value = renderTargets[currentTarget].texture;
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>